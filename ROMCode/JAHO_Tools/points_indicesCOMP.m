function [B A_ordered] = points_indicesCOMP(A,M)
% Given the gauss-points indices A, points_indices returns the
% corresponding point indices B (M is the number of components of the
% concerned vectorial field)
%   indices B cor
if nargin == 0 
    A = [1 2 3 4 17 18 19 20 2]; 
    M = 4 ;
end


 

 igauss =  mod(A,M) ;
 [ind1] = find(igauss==0)  ;
 if ~isempty(ind1)
     igauss(ind1) = M ;
 end
 %disp('... calculating points ...')
 B = (A-igauss)/M+1;
 
 B = unique(B);



% j_glo = gc-4*gc_floor+1;
% 
% points  = gc_floor ; 
% 
% indices = j_glo ;




% % Rows included in the gappy PHI matrix are, not only those
% % generated by randomly-based algorithm, but also the accompanying stress
% % components; i.e., if the row 1 is selected (1st gauss point, 1st
% % component),
% % then, automatically, rows 2,3,4 are appended.
% 
% 
% % Which points ?
% if nargin == 0
%     ng = 4 ;
%     load('prueba.mat');
%     combinations = combinations_old; %(:,1:7) ;
%     combinations = [4 3 3 1 ; 8 5 7 7; 9 2 3 4]';
%     CLASS_INTEGER = 'uint16';
% end
% %dbstop('21')
% 
% 
% 
% igauss =  mod(combinations,ng) ;
% [ind1] = find(igauss==0)  ;
% if ~isempty(ind1)
%     igauss(ind1) = ng ;
% end
% disp('... calculating points ...')
% points = (combinations-igauss)/ng+1;
% clear igauss
% 
% disp('... allocating memory for extended combination matrix...')
% combinations_new= zeros(ng*size(combinations,1),size(combinations,2),CLASS_INTEGER);
% 
% for jn = 1:ng
%     ind_ini = (jn-1)*size(combinations,1)+1;
%     inf_fin = jn*size(combinations,1);
%     combinations_new(ind_ini:inf_fin,:) = (points-1)*ng+jn;
% end
